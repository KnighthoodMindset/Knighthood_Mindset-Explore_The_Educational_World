<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Type Checking in Compiler Design | Tech Nexus | Knighthood Mindest</title>
  <link rel="stylesheet" href="exp.css" />
</head>
<body>
  <div class="top-banner">
    <h1>Tech Nexus</h1>
    <h2>Your Study Companion</h2>
  </div>

  <main>

    <section>
        <h3>Type Checking in Compiler Design</h3>
        <p>Type checking is an essential phase in the compilation process that ensures the semantic correctness of the program. In simple terms, type checking verifies that the operations in the source code are performed on compatible data types. It checks for type errors such as trying to add a string to an integer or dividing a number by a string. Type checking helps ensure that the program behaves as intended and prevents runtime errors related to type mismatches.</p>
    </section>

    <section>
        <h4>What is Type Checking?</h4>
        <p>Type checking involves verifying that the data types of variables, functions, and expressions in a program are used consistently and according to the rules of the programming language. It ensures that operands involved in operations (such as arithmetic, relational, and logical operators) are of compatible types, and that variables are assigned appropriate types.</p>
        <p>In many programming languages, type checking can be done either at compile-time (statically typed languages) or at runtime (dynamically typed languages).</p>
    </section>

    <section>
        <h4>Role of Type Checking</h4>
        <ul>
            <li><strong>Type Safety</strong>: Type checking prevents type errors that would otherwise lead to unpredictable behavior or crashes at runtime.</li>
            <li><strong>Semantic Analysis</strong>: After the syntactic correctness is ensured through parsing, type checking guarantees that the operations on variables, expressions, and function calls are semantically valid.</li>
            <li><strong>Error Detection</strong>: Type checking helps in identifying mismatches in data types early in the compilation process, saving time and effort by avoiding runtime errors.</li>
        </ul>
    </section>

    <section>
        <h4>Types of Type Checking</h4>
        <h5>Static Type Checking (Compile-time)</h5>
        <p>Type errors are detected at compile-time. The compiler checks whether variables and expressions conform to the specified types. Languages like Java, C, and C++ are statically typed languages that rely heavily on static type checking.</p>
        <p><strong>Example:</strong></p>
        <pre>
            int a = 10;
            String b = "hello";
            a = b;  // Type error: cannot assign a String to an int variable
        </pre>

        <h5>Dynamic Type Checking (Runtime)</h5>
        <p>Type errors are detected at runtime. Languages like Python, JavaScript, and Ruby use dynamic type checking, where types are determined during program execution.</p>
        <p><strong>Example:</strong></p>
        <pre>
            a = 10
            b = "hello"
            a = b  // Type error at runtime: cannot assign a string to an integer
        </pre>
    </section>

    <section>
        <h4>Key Type Checking Operations</h4>
        <h5>Assignment Checking</h5>
        <p>Type checking verifies whether the variable on the left-hand side of an assignment is compatible with the type of the expression on the right-hand side.</p>
        <pre>
            int a = 5;
            a = "hello";  // Error: incompatible types (int and string)
        </pre>

        <h5>Expression Type Checking</h5>
        <p>Verifies whether operands in expressions are of compatible types.</p>
        <pre>
            int result = 5 + "hello";  // Error: cannot add integer and string
        </pre>

        <h5>Function Call Type Checking</h5>
        <p>Ensures that the function arguments match the expected parameter types.</p>
        <pre>
            int add(int x, int y) {
                return x + y;
            }

            add("5", 10);  // Error: incompatible type (string and int)
        </pre>

        <h5>Return Type Checking</h5>
        <p>Verifies that the return type of a function matches the expected type.</p>
        <pre>
            float divide(int a, int b) {
                return a / b;  // Okay, return type is float
            }

            int divide(int a, int b) {
                return a / b;  // Error: function expected to return int, but it returns float
            }
        </pre>
    </section>

    <section>
        <h4>How Type Checking Works in Compilers</h4>
        <h5>Type Tables</h5>
        <p>A type table is used by the compiler to store information about the types of variables, functions, and expressions in the program. The symbol table (generated during the lexical analysis phase) may contain information about variable names, types, and scopes.</p>

        <h5>Type Rules</h5>
        <p>The compiler follows the type rules of the programming language to determine whether types are compatible. For example, a language might specify that integers can only be added to integers and floating-point numbers to floating-point numbers.</p>

        <h5>Type Inference</h5>
        <p>Some compilers perform type inference to automatically deduce the types of variables and expressions based on their usage. This is common in languages like Haskell and TypeScript, where you don't have to explicitly declare types for every variable or function.</p>

        <h5>Error Handling</h5>
        <p>If a type mismatch is detected, the compiler produces a type error message. The error message typically includes the line number and a description of the error, allowing the developer to correct the issue.</p>
    </section>

    <section>
        <h4>Type Checking Examples</h4>
        <h5>Example 1: Static Type Checking</h5>
        <pre>
            int add(int a, int b) {
                return a + b;
            }

            float x = 3.5;
            add(x, 4);  // Error: expected int arguments, but received float
        </pre>

        <h5>Example 2: Dynamic Type Checking</h5>
        <pre>
            def add(a, b):
                return a + b

            print(add(2, 3))  # Works fine, adds numbers

            print(add(2, "hello"))  # Error: can't add int and string
        </pre>
    </section>

    <section>
        <h4>Type Checking Strategies</h4>
        <h5>Single-Pass Checking</h5>
        <p>The compiler processes the program in a single pass, checking types as it goes. Simple and fast, but might not catch certain type errors in complex programs.</p>

        <h5>Two-Pass Checking</h5>
        <p>The compiler performs two passes: one for declaration analysis (ensuring variables are declared with the correct types) and one for usage analysis (ensuring types are compatible during operations). More accurate, but slower than single-pass checking.</p>

        <h5>Constraint-Based Type Checking</h5>
        <p>Used in languages that support type inference, the compiler generates constraints based on the usage of variables and expressions and solves them to infer types.</p>
    </section>

    <section>
        <h4>Applications of Type Checking</h4>
        <table>
            <thead>
                <tr>
                    <th>Application</th>
                    <th>Purpose</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Error Detection</strong></td>
                    <td>Detects type errors early during compilation.</td>
                </tr>
                <tr>
                    <td><strong>Optimization</strong></td>
                    <td>Helps identify opportunities for optimizations (e.g., type coercion).</td>
                </tr>
                <tr>
                    <td><strong>Code Generation</strong></td>
                    <td>Assists in generating machine code based on type-safe operations.</td>
                </tr>
                <tr>
                    <td><strong>Language Design</strong></td>
                    <td>Aids in defining and enforcing consistent type systems for programming languages.</td>
                </tr>
                <tr>
                    <td><strong>Debugging</strong></td>
                    <td>Type errors can be caught during compilation, reducing runtime bugs.</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section>
        <h4>Advantages of Type Checking</h4>
        <ul>
            <li><strong>Early Error Detection</strong>: Catches type errors during compilation rather than at runtime.</li>
            <li><strong>Ensures Correctness</strong>: Prevents mismatched operations, ensuring the program behaves as expected.</li>
            <li><strong>Optimizations</strong>: Type information can help with optimization strategies in later compiler stages (e.g., dead code elimination, constant folding).</li>
            <li><strong>Improved Program Safety</strong>: Helps ensure that certain classes of errors (e.g., invalid operations) do not occur.</li>
        </ul>
    </section>

    <section>
        <h4>Limitations of Type Checking</h4>
        <ul>
            <li><strong>Complexity in Dynamic Languages</strong>: Type checking in dynamic languages (e.g., Python, JavaScript) can be more difficult and might lead to more runtime errors.</li>
            <li><strong>Performance Overhead</strong>: Extensive type checking may introduce performance overhead during compilation.</li>
            <li><strong>Inflexibility in Some Languages</strong>: Strict type systems in languages like C++ or Java can sometimes lead to limitations in expressiveness or flexibility.</li>
        </ul>
    </section>

    <section>
        <h4>Conclusion</h4>
        <p>Type checking is a crucial part of the compilation process that ensures programs adhere to the type constraints defined by the programming language. It helps in detecting errors early, optimizing code, and ensuring that the program executes safely and correctly. Depending on whether the language is statically or dynamically typed, type checking can be performed either at compile-time or runtime, offering different trade-offs in terms of safety and flexibility.</p>
    </section>


  </main>

  <footer>
  <a href="CD_UNIT3.html" class="back-btn">← Back to Unit 3 Topics</a>
  </footer>

</body>
</html>
