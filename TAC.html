
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Three Address Code (TAC) | Tech Nexus | Knighthood Mindest</title>
  <link rel="stylesheet" href="exp.css" />
</head>
<body>
  <div class="top-banner">
    <h1>Tech Nexus</h1>
    <h2>Your Study Companion</h2>
  </div>

  <main>


    <section>
        <h3>Three Address Code (TAC)</h3>
    </section>

    <section>
        <h4>Introduction</h4>
        <p>
            Three Address Code (TAC) is a form of intermediate representation (IR) used in the process of compiling high-level programming languages into machine code. As the name suggests, each instruction in TAC can contain at most three addresses (or operands). These addresses may be variables, constants, or temporary names created by the compiler.
        </p>
        <p>
            TAC serves as a bridge between the source code and target machine code, providing a structured yet simplified way of expressing computations.
        </p>
    </section>

    <section>
        <h4>Structure of TAC</h4>
        <p>Each instruction in Three Address Code typically follows one of the formats below:</p>
        <pre>
x = y op z       → binary operation  
x = op y         → unary operation  
x = y            → assignment  
goto label       → unconditional jump  
if x relop y goto label  → conditional jump
        </pre>
        <p>Here:</p>
        <ul>
            <li><code>x</code>, <code>y</code>, <code>z</code> are variables or temporary variables</li>
            <li><code>op</code> is an operator (+, -, *, /, etc.)</li>
            <li><code>relop</code> is a relational operator (==, !=, &gt;, &lt;, etc.)</li>
        </ul>
    </section>

    <section>
        <h4>Purpose and Importance</h4>
        <ul>
            <li>TAC allows compilers to perform optimizations easily.</li>
            <li>It simplifies complex expressions into smaller steps.</li>
            <li>It enables target-independent analysis and transformation.</li>
            <li>It forms the basis for code generation and register allocation.</li>
        </ul>
    </section>

    <section>
        <h4>Examples</h4>

        <h5>Example 1: Arithmetic Expression</h5>
        <p>For the expression:</p>
        <pre>
a = b + c * d
        </pre>
        <p>The equivalent TAC might be:</p>
        <pre>
t1 = c * d  
t2 = b + t1  
a = t2
        </pre>

        <h5>Example 2: If-Else Statement</h5>
        <pre>
if (a &lt; b)  
   x = y + z;
else  
   x = y - z;
        </pre>
        <p>TAC:</p>
        <pre>
if a &lt; b goto L1  
goto L2  
L1: x = y + z  
goto L3  
L2: x = y - z  
L3:
        </pre>
    </section>

    <section>
        <h4>Types of TAC Instructions</h4>
        <table border="1">
            <tr>
                <th>Type</th>
                <th>Example</th>
            </tr>
            <tr>
                <td>Assignment</td>
                <td>x = y</td>
            </tr>
            <tr>
                <td>Unary operation</td>
                <td>x = -y</td>
            </tr>
            <tr>
                <td>Binary operation</td>
                <td>x = y + z</td>
            </tr>
            <tr>
                <td>Conditional jump</td>
                <td>if x &lt; y goto L1</td>
            </tr>
            <tr>
                <td>Unconditional jump</td>
                <td>goto L2</td>
            </tr>
            <tr>
                <td>Procedure call</td>
                <td>call p, n</td>
            </tr>
            <tr>
                <td>Return</td>
                <td>return x</td>
            </tr>
            <tr>
                <td>Label definition</td>
                <td>L1:</td>
            </tr>
        </table>
    </section>

    <section>
        <h4>Temporary Variables</h4>
        <ul>
            <li>Temporaries (t1, t2, ...) are used to store intermediate results.</li>
            <li>They simplify complex expressions and aid in optimization and code generation.</li>
        </ul>
    </section>

    <section>
        <h4>Applications of TAC</h4>
        <table border="1">
            <tr>
                <th>Area</th>
                <th>Purpose</th>
            </tr>
            <tr>
                <td>Intermediate Representation</td>
                <td>Acts as a bridge between source code and machine code</td>
            </tr>
            <tr>
                <td>Optimization</td>
                <td>Enables easy application of optimization techniques</td>
            </tr>
            <tr>
                <td>Code Generation</td>
                <td>Translates naturally to assembly-like target code</td>
            </tr>
            <tr>
                <td>Semantic Checking</td>
                <td>Helps perform type checking, expression validation</td>
            </tr>
            <tr>
                <td>Register Allocation</td>
                <td>Temporaries in TAC correspond to registers in target machine code</td>
            </tr>
        </table>
    </section>

    <section>
        <h4>Advantages of TAC</h4>
        <ul>
            <li>Simple and flexible representation</li>
            <li>Easy to generate and transform</li>
            <li>Supports machine-independent optimizations</li>
            <li>Ideal for data flow analysis, constant folding, common subexpression elimination, etc.</li>
        </ul>
    </section>

    <section>
        <h4>Limitations</h4>
        <ul>
            <li>Still abstract, so must eventually be lowered to target assembly</li>
            <li>Not always optimal in size or performance</li>
            <li>Requires additional effort for register assignment</li>
        </ul>
    </section>

    <section>
        <h4>Conclusion</h4>
        <p>
            Three Address Code (TAC) is a powerful and widely-used intermediate form in compilers. It strikes a balance between human-readability and machine-efficiency, offering a versatile way to represent and manipulate programs. By breaking complex expressions and constructs into simpler steps, TAC enables effective optimization and easier translation to machine code.
        </p>
    </section>


    
  </main>

  <footer>
  <a href="CD_UNIT3.html" class="back-btn">← Back to Unit 3 Topics</a>
  </footer>

</body>
</html>
