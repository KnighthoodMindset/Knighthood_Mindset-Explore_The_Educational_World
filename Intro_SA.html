<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Syntax Analysis | Tech Nexus | Knighthood Mindest</title>
  <link rel="stylesheet" href="exp.css" />
</head>
<body>
  <div class="top-banner">
    <h1>Tech Nexus</h1>
    <h2>Your Study Companion</h2>
  </div>

  <main>
    <section>
      <h3>Syntax Analysis</h3>
    </section>
    <section>
      <p>Syntax Analysis, also known as parsing, is the second phase of a compiler. It takes the linear sequence of tokens generated by the lexical analyzer and transforms them into a hierarchical structure known as a parse tree or syntax tree. This process helps in verifying whether the tokens form a valid program structure according to the context-free grammar (CFG) of the language.</p>
      <h5>Purpose of Syntax Analysis</h5>
      <p>The main goal of syntax analysis is to check the syntax of the program and ensure it adheres to the grammatical rules of the programming language. It also helps in the construction of the parse tree, which serves as the input for the next compiler phase — semantic analysis.</p>
      <h5>Parse Tree / Syntax Tree</h5>
      <p>A parse tree is a tree representation that shows how a sentence in a language is derived using the production rules of a grammar. It represents the syntactic structure of the source code. Each internal node represents a non-terminal, and each leaf node represents a terminal or token.</p>
    </section>
    <section>
      <h4>Grammar Used in Syntax Analysis</h4>
      <p>Syntax analyzers use a context-free grammar (CFG), which is a formal way of describing the syntactic structure of programming languages. CFG consists of:</p>
      <li><strong>Non-terminals: </strong>Variables representing groups of rules</li>
      <li><strong>Terminals: </strong>Actual symbols (tokens)</li>
      <li><strong>Production rules: </strong>Rules that describe how terminals and non-terminals combine</li>
      <li><strong>Start symbol: </strong>A special non-terminal from which parsing begins</li>
    </section>
    <section>
      <h5>Example CFG:</h5>
      <p>E → E + T | T </p>
      <p>T → T * F | F</p>
      <p>F → (E) | id</p>
      <p>This grammar describes the rules for parsing arithmetic expressions with operators `+`, `*`, parentheses, and identifiers.</p>
    </section>
    <section>
      <h4>Types of Parsers</h4>
      <p>Parsers are classified into two major types based on the direction of construction of the parse tree:</p>
      <h5>1. Top-Down Parsing:</h5>
      <li>Begins with the start symbol and tries to derive the input string.</li>
      <li>Constructs the parse tree from top to bottom.</li>
      <li>Uses leftmost derivations.</li>
      <li>Examples: Recursive Descent Parser, LL(1) Parser.</li>
      <li>Simple to implement but struggles with left-recursive grammars.</li>

      <h5>2. Bottom-Up Parsing</h5>
      <li>Starts with the input symbols and attempts to reduce them to the start symbol using production rules.</li>
      <li>Builds the parse tree from leaves to root.</li>
      <li>Uses rightmost derivations in reverse.</li>
      <li>Examples: LR(0), SLR(1), LALR(1), CLR(1).</li>
      <li>More powerful and handles a larger set of grammars.</li>
    </section>  
    <section>
      <h4>Syntax Errors and Recovery</h4>
      <p>The syntax analyzer also handles syntax errors that occur due to violations of grammar rules. Errors like missing semicolons, unmatched brackets, or misplaced keywords are caught at this stage.</p>
      <p>Error handling techniques include:</p>
      <li><strong>Panic mode recovery: </strong>skips input until a synchronizing token is found.</li>
      <li><strong>Phrase level recovery: </strong>performs local corrections.</li>
      <li><strong>Error productions: </strong>add error rules in grammar.</li>
      <li><strong>Global correction: </strong>minimum changes made to make input valid.</li>
    </section>
    <section>
      <h4>Tools for Syntax Analysis</h4>
      <p>There are parser generators that automate the process of building parsers:</p>
      <li><strong>YACC (Yet Another Compiler Compiler): </strong>Generates C code for parsers.</li>
      <li><strong>Bison: </strong>GNU version of YACC.</li>
      <li><strong>ANTLR: </strong>Modern tool supporting multiple languages like Java, C#, Python.</li>
    </section> 
    <section>
      <h4>Advantages of Syntax Analysis</h4>
      <li>Ensures the code structure is correct and follows grammar rules.</li>
      <li>Helps generate intermediate representations like syntax trees.</li>
      <li>Detects and locates syntax errors early in the compilation process.</li>
      <li>Separates concerns: structure checking (syntax) vs meaning checking (semantics).</li>
    </section> 
    <section>
      <h4>Limitations</h4>
      <li>Complex grammars require complex parser logic.</li>
      <li>Difficult to handle all syntax errors gracefully in large codebases.</li>
      <li>Ambiguous grammars can cause parsing conflicts.</li>
      <li>Requires careful grammar design to avoid left recursion and ambiguity.</li>
    </section>
    <section>
      <h4>Conclusion</h4>
      <p>Syntax Analysis is a crucial phase in the compilation process that validates the structural correctness of source code. By using context-free grammars, it constructs parse trees and detects syntax errors. It lays the foundation for the next phases like semantic analysis and code generation. With efficient parsing techniques and tools, this phase greatly improves the compiler's accuracy, error reporting, and performance.</p>
    </section>
    
  </main>

  <footer>
  <a href="CD_UNIT1.html" class="back-btn">← Back to Unit 1 Topics</a>
  </footer>

</body>
</html>